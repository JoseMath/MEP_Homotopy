# FiberHomotopy.m
# The main function
	Inputs: 
	# A: k by (k+1) cell array containing all matrix coefficients
	# (optional) Number of Newton iteration in the last step: the default value is k*(max(n)+5)
	# (optional) Method: 1 — structured method, 0 — naive method (default)
	
	Outputs:
	# EigenValue: n1*…*nk by k cell, where each column is a lambda variable group  
	# EigenVector:  n1*…*nk by k cell, where each row is an eigenvector solution (x1,…,xk)
	# SEigenValue: eigenvalues of the start system (the k GEPs)
	# SEigenVector: eigenvectors of the start system (the k GEPs)
	# TimeEachPath: timing of each path
	# LastNewton: number of Newton iteration in the last step
	# JacG: Jacobian matrix of the target system
	# C: linear constraints on eigenvectors
	# Newtoniteration: total number of Newton iterations

	Example:
	% Randomly generated system with k = 3, n1=n2=n3 = 5 (can just copy paste the code to try it)
	k = 3;
	ni = 3;
	n = ni*ones(1,k);
    m=2*ones(1,k)
	Amatrix = rands(k*ni,(k+1)*ni)+1i*randn(k*ni,(k+1)*ni);
	A = mat2cell(Amatrix,n,ni*ones(1,k+1));
 FiberHomotopy(A,n)
 FiberHomotopy(A,m)
  	[EigenValue,EigenVector,SEigenValue,SEigenVector,TimeEachPath,LastNewton,JacG,C,NewtonIteration] = FiberHomotopy(A); % naive method with default number of Newton iteration in the last step
	[EigenValue,EigenVector,SEigenValue,SEigenVector,TimeEachPath,LastNewton,JacG,C,NewtonIteration] = FiberHomotopy(A,50); % naive method with 50 Newton iteration in the last step (recommended; the default number is usually not the best one)
	[EigenValue,EigenVector,SEigenValue,SEigenVector,TimeEachPath,LastNewton,JacG,C,NewtonIteration] = FiberHomotopy(A,50,1); % structured method with 50 Newton iteration in the last step

%% Write Bertini File.
    Str1='/Users/jo/Desktop/Dump/'
    Str2='input_target'
	k = 3;	ni = 3;	n = ni*ones(1,k);    m=2*ones(1,k);
	Amatrix = rands(k*ni,(k+1)*ni)+1i*randn(k*ni,(k+1)*ni);
	A = mat2cell(Amatrix,n,ni*ones(1,k+1));
    L1=rands(k-1,k);    L2=rands(k-1,k);    L3=rands(k-1,k);
    G1=rands(k-1,k);
    G2=rands(k-1,k);

%% Flutter 
    coefA=[P,-Q,-R;conj(P),-conj(Q),-conj(R)]
	A = mat2cell(coefA,20*ones(1,2),20*ones(1,2+1))
    m=[12,12]
%% Hom Flutter
    coefA=[rand(1),rand(1),rand(1),rand(1);zeros(20,20),P,-Q,-R;zeros(20,20),conj(P),-conj(Q),-conj(R)]
    A=cell(3,4)
    hl=[rand(1),rand(1),rand(1),rand(1)]
    A(1,1)=mat2cell(hl(1),[1],[1])
    A(1,2)=mat2cell(hl(2),[1],[1])
    A(1,3)=mat2cell(hl(3),[1],[1])
    A(1,4)=mat2cell(hl(4),[1],[1])

	A(2,:) = mat2cell([zeros(20,20),P,-Q,-R],20*ones(1,1),20*ones(1,2+2))
	A(3,:) = mat2cell([zeros(20,20),conj(P),-conj(Q),-conj(R)],20*ones(1,1),20*ones(1,2+2))

    m=[1,12,12]
  	[EigenValue,EigenVector,SEigenValue,SEigenVector,TimeEachPath,LastNewton,JacG,C,NewtonIteration,LastTValue]=restrictedFiberHomotopy(A,m,1000,.00001,.000001);
#######################

# EvaluateHi.m
# Sub function; the EvaluateHi function evaluate the Jacobian matrix with the most recent eigenpair

#######################

# RBackwardError.m
# The function that compute the relative backward error

	# Inputs: the approximate eigenvalue, eigenvector and coefficient matrices

	# Example:
	RBE = BackwardError(EigenValue,EigenVector,A);




 










